# ROLE AND GOAL
- You will be provided with multiple Python "interface descriptions" that all describe the same component, plus the original source code from which those interfaces were generated.
- Produce one merged, canonical Python interface module for this component. This is a merge, not a concatenation: deduplicate, normalize, and resolve conflicts using the rules below and use the source code as the primary source of truth.

# OUTPUT FORMAT
- Return exactly one Python source file (plain text content) and nothing else. Do not include any surrounding commentary, explanation, or extra keys.
- The file must contain, in this order:
	- Imports (only what is needed for the interface: typing, dataclasses, numpy typing if used, etc.)
	- The initializer function (if present in code) with exact name and signature.
	- The main processing function with exact name from the source, full signature, type hints.
	- Any additional auxiliary functions required by the canonical interface with signatures.
	- A test section (if test cases are present across inputs) guarded by a clear marker (e.g., if name == "main": or a test_ prefixed functions for pytest).
	- A module-level COMMENTS variable containing an ordered list of short dicts describing any ambiguity, assumption, or deviation made during merging.

# GENERAL MERGING PRINCIPLES
1. Source-of-truth and precedence
- The provided source code file is authoritative for function and class names, parameter roles, and existence. If any input interface claims an item that is not in or contradicts the source code, prefer the code.
- When multiple inputs disagree on attributes, resolve in this order: a) Value implied by the source code (names, parameter roles, types if annotated, default values). b) Value consistent with the majority of input interfaces. c) The most specific/strict typing (e.g., int over float when code supports int values) that is not in conflict with the code. d) The clearest, most complete docstring/content. If needed, synthesize concise, non-duplicative descriptions from multiple sources.
- If a variable appears both as a configuration constant and as a runtime variable across inputs, prefer the code's treatment. If code is silent, prefer parameter (constant) if used only at initialization, otherwise variable.

2. Canonical naming and normalization
- Preserve symbol names exactly as in the source code for functions, classes, constants, and public variables.
- Drop purely internal/private helpers (leading underscore) that are not part of the public interface.

3. Typing, annotations, and defaults
- Use PEP 484 type hints on all public function signatures and dataclasses.
- Include clear docstring parameter descriptions including units and valid ranges, using the best available description from inputs or synthesized text.

5. Init and process functions
- init.name must match the initializer symbol in the source (if present). Provide a precise signature matching the source; if code offers an initializer class init instead, provide a factory function with the same name and signature.
- process.name must be the main routine name from the code. Compose process docstring from the best available descriptions; include a brief "Behavior summary" with inputs used, outputs produced, and side effects (state updates).

6. Function signatures and deduplication
- Deduplicate parameters by name; merge annotations and defaults following precedence rules above.
- If parameters are positional-only in the source, keep them positional-only; otherwise prefer explicit keyword names in signature for clarity.

7. Tests
- If test cases appear in input interfaces or the source, include pytest-compatible test_* functions at the bottom. Use small, deterministic inputs derived from inputs; prefer code-provided examples. If contradictory expected outputs appear, prefer the source-coded behavior or majority consensus.
- Tests should import the generated interface symbols from the module namespace (i.e., self-contained within the file).

8. Comments and assumptions
- Include a module-level COMMENTS listing any ambiguities.

# SPECIAL RULES FOR AUTOMATED USE
- The produced module must be importable (no print-only examples or unreachable code at top level).
- Minimize external dependencies. Do not import heavy libraries; when numpy or pandas are used in the source, reflect that in the imports.
- Keep the public API surface minimal: expose only the canonical functions that the source exposes. If the source exposes an all list, preserve or synthesize one matching the canonical interface.

# IMPORTANT FINAL INSTRUCTIONS
- Produce only the Python module content described above, and nothing else.
- Use the source code file as primary truth for names, typing, defaults, and behavior. When the source omits something required by a clear interface (types, units, ranges), synthesize conservative, safe values and document them in COMMENTS.
- If any decision required you to remove or rename a symbol present in input interfaces but absent in source, note that action and the reason in COMMENTS.
- If you cannot confidently merge due to contradictory evidence and the source code is silent, pick the safer, more general option and note this in COMMENTS.